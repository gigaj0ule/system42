/* Includes ------------------------------------------------------------------*/

#include "communication.h"
#include "nvm_config.hpp"

// For custom definitions
#include "sketch.hpp"

// For reboot function
#include <cmsis_os.h>

#include "interface_usb.h"
#include "interface_uart.h"
#include "interface_can.hpp"
#include "interface_i2c.h"

#include "odrive_main.h"
#include "freertos_vars.h"
#include "utils.h"
#ifndef FW_VERSION_MAJOR
#include "../build/version.h" // autogenerated based on Git state
#endif
#include <memory>
//#include <usbd_cdc_if.h>
//#include <usb_device.h>
//#include <usart.h>
#include <gpio.h>

#include <type_traits>

/* Private defines -----------------------------------------------------------*/
/* Private macros ------------------------------------------------------------*/
/* Private typedef -----------------------------------------------------------*/
/* Global constant data ------------------------------------------------------*/
/* Global variables ----------------------------------------------------------*/
extern PowernetNamespace pntp;

int64_t serial_number;
char serial_number_str[13]; // 12 digits + null termination

/* Private constant data -----------------------------------------------------*/
/* Private variables ---------------------------------------------------------*/

#if HW_VERSION_MAJOR == 3
// Determine start address of the OTP struct:
// The OTP is organized into 16-byte blocks.
// If the first block starts with "0xfe" we use the first block.
// If the first block starts with "0x00" and the second block starts with "0xfe",
// we use the second block. This gives the user the chance to screw up once.
// If none of the above is the case, we consider the OTP invalid (otp_ptr will be NULL).
const uint8_t* otp_ptr =
    (*(uint8_t*)FLASH_OTP_BASE == 0xfe) ? (uint8_t*)FLASH_OTP_BASE :
    (*(uint8_t*)FLASH_OTP_BASE != 0x00) ? NULL :
        (*(uint8_t*)(FLASH_OTP_BASE + 0x10) != 0xfe) ? NULL :
            (uint8_t*)(FLASH_OTP_BASE + 0x10);

// Read hardware version from OTP if available, otherwise fall back
// to software defined version.
const uint8_t hw_version_major = otp_ptr ? otp_ptr[3] : HW_VERSION_MAJOR;
const uint8_t hw_version_minor = otp_ptr ? otp_ptr[4] : HW_VERSION_MINOR;
const uint8_t hw_version_variant = otp_ptr ? otp_ptr[5] : HW_VERSION_VOLTAGE;
#else
#error "not implemented"
#endif

// the corresponding macros are defined in the autogenerated version.h
const uint8_t fw_version_major = FW_VERSION_MAJOR;
const uint8_t fw_version_minor = FW_VERSION_MINOR;
const uint8_t fw_version_revision = FW_VERSION_REVISION;
const uint8_t fw_version_unreleased = FW_VERSION_UNRELEASED; // 0 for official releases, 1 otherwise

osThreadId comm_thread;
volatile bool endpoint_list_valid = false;

/* Private function prototypes -----------------------------------------------*/

static inline void get_serial_number() {
    // This procedure of building a USB serial number should be identical
    // to the way the STM's built-in USB bootloader does it. This means
    // that the device will have the same serial number in normal and DFU mode.
    uint32_t uuid0 = *(uint32_t *)(0x1FFFF7E0 + 0);
    uint32_t uuid1 = *(uint32_t *)(0x1FFFF7E0 + 4);
    uint32_t uuid2 = *(uint32_t *)(0x1FFFF7E0 + 8);
    uint32_t uuid_mixed_part = uuid0 + uuid2;

    serial_number = ((uint64_t)uuid_mixed_part << 16) | (uint64_t)(uuid1 >> 16);
}

float oscilloscope_[OSCILLOSCOPE_CHANNELS][OSCILLOSCOPE_SIZE] = {0};
uint16_t oscilloscope_sample_index_[OSCILLOSCOPE_CHANNELS] = {0};
size_t oscilloscope_pos = 0;

/* NVM Functions -----------------------------------------------------------*/
char cached_device_id[60] = {0};

struct NvmBuiltins_t {
    char device_id[60] = "";
};

NvmBuiltins_t NvmBuiltins;

typedef Config<
    NvmBuiltins_t
> ConfigFormat_2;

//void erase_configuration(void) {
//    NVM_erase();
//    reboot_system();
//}


/* Static linkage -------------------------------------------------*/
static CAN_context can1_ctx;

// Helper class because the protocol library doesn't yet
// support non-member functions
// TODO: make this go away
class StaticFunctions {
public:
    void save_configuration_static(void) { 
        save_configuration(); 
    }
    void erase_configuration_static(void) { 
        erase_configuration(); 
    }
    void reboot_system_static(void) { 
        NVIC_SystemReset(); 
    }
    void enter_dfu_static(void) { 
        enter_dfu_mode(); 
    }
    float get_oscilloscope_val(int32_t channel, int32_t index) { 
        return oscilloscope_[channel][index]; 
    }
    float get_adc_voltage_(int32_t gpio) { 
        return get_adc_voltage(get_gpio_port_by_pin(gpio), get_gpio_pin_by_pin(gpio)); 
    }
} static_functions;


// When adding new functions/variables to the protocol, be careful not to
// blow the communication stack. You can check comm_stack_info to see
// how much headroom you have.
static inline auto make_obj_tree() {
    return make_protocol_member_list(

        // Volatile Objects
        make_protocol_object("volatile",

            pntp.volatile_properties(), 
        
            make_protocol_number_kw(
                &vbus_voltage,
                property_name = "vbus_voltage", 
                property_is_read_only = true
            ),
            make_protocol_number_kw(
                const_cast<bool *>(&user_config_loaded_),
                property_name = "user_config_loaded", 
                property_is_read_only = true
            ),
            make_protocol_number_kw(
                &brake_resistor_armed,
                property_name = "brake_resistor_armed", 
                property_is_read_only = true
            ),
            make_protocol_object("system_stats",
                make_protocol_number_kw(
                    &system_stats_.uptime,
                    property_name = "uptime",
                    property_is_read_only = true 
                ),
                make_protocol_number_kw(
                    &system_stats_.min_heap_space,
                    property_name = "min_heap_space",
                    property_is_read_only = true 
                ),
                make_protocol_number_kw(
                    &system_stats_.min_stack_space_axis0,
                    property_name = "min_stack_space_axis0",
                    property_is_read_only = true 
                )//,
                
                /*
                make_protocol_number_kw("min_stack_space_axis1", &system_stats_.min_stack_space_axis1),
                make_protocol_number_kw("min_stack_space_comms", &system_stats_.min_stack_space_comms),
                make_protocol_number_kw("min_stack_space_usb", &system_stats_.min_stack_space_usb),
                make_protocol_number_kw("min_stack_space_uart", &system_stats_.min_stack_space_uart),
                make_protocol_number_kw("min_stack_space_usb_irq", &system_stats_.min_stack_space_usb_irq),
                make_protocol_number_kw("min_stack_space_startup", &system_stats_.min_stack_space_startup),
                */

                /*make_protocol_object("usb",
                    make_protocol_number_kw("rx_cnt", &usb_stats_.rx_cnt),
                    make_protocol_number_kw("tx_cnt", &usb_stats_.tx_cnt),
                    make_protocol_number_kw("tx_overrun_cnt", &usb_stats_.tx_overrun_cnt)
                )*/
                /*,
                make_protocol_object("i2c",
                    make_protocol_number_kw("addr", &i2c_stats_.addr),
                    make_protocol_number_kw("addr_match_cnt", &i2c_stats_.addr_match_cnt),
                    make_protocol_number_kw("rx_cnt", &i2c_stats_.rx_cnt),
                    make_protocol_number_kw("error_cnt", &i2c_stats_.error_cnt)
                )*/
            )
            ,
            make_protocol_object("config",

                make_protocol_number_kw(
                    &board_config.brake_resistance,
                    property_name = "brake_resistance" 
                ),
                // TODO: changing this currently requires a reboot - fix this
                make_protocol_number_kw(
                    &board_config.enable_uart,
                    property_name = "enable_uart"
                ),
                //make_protocol_number_kw("enable_i2c_instead_of_can" , &board_config.enable_i2c_instead_of_can), // requires a reboot
                //make_protocol_number_kw("enable_ascii_protocol_on_usb", &board_config.enable_ascii_protocol_on_usb),
                make_protocol_number_kw(
                    &board_config.dc_bus_undervoltage_trip_level,
                    property_name = "dc_bus_undervoltage_trip_level"
                ),
                make_protocol_number_kw(
                    &board_config.dc_bus_overvoltage_trip_level,
                    property_name = "dc_bus_overvoltage_trip_level"
                )
            ),
            #ifdef __E_VEHICLE_HPP
            //make_protocol_object("e_vehicle", ev->make_protocol_definitions()),
            #endif
            
            make_protocol_object(
                "axis0", 
                axes[0]->make_protocol_definitions()
            ),

            //make_protocol_object("can", can1_ctx.make_protocol_definitions()),
            make_protocol_function_kw(
                static_functions, 
                &StaticFunctions::get_oscilloscope_val, 
                property_name = "get_oscilloscope_val", 
                function_arguments = std::array<const char *, 2>{"channel", "index"}
            ),
            make_protocol_function_kw(
                static_functions, 
                &StaticFunctions::get_adc_voltage_, 
                property_name = "get_adc_voltage", 
                function_arguments = std::array<const char *, 1>{"gpio"}
            )
        ),
        
        // Non Volatile Objects
        make_protocol_object("nvm",

            make_protocol_string_kw(
                &NvmBuiltins.device_id, 
                property_name = "id", 
                property_length = sizeof(NvmBuiltins.device_id),
                property_is_non_volatile = true
            ),
            
            pntp.nonvolatile_properties(),

            make_protocol_function_kw(
                static_functions, 
                &StaticFunctions::save_configuration_static,
                property_name = "save"
            ),
            make_protocol_function_kw(
                static_functions, 
                &StaticFunctions::erase_configuration_static,
                property_name = "erase"    
            )        
        ),

        // Event handlers (if any)
        make_protocol_object("events",
            pntp.interrupt_properties()
        ),

        make_protocol_function_kw(
            static_functions, 
            &StaticFunctions::reboot_system_static,
            property_name = "reboot"
        ),
        make_protocol_function_kw(
            static_functions, 
            &StaticFunctions::enter_dfu_static,
            property_name = "dfu"
        )
    );
}

using tree_type = decltype(make_obj_tree());
uint8_t tree_buffer[sizeof(tree_type)];

void init_communication(void) {

    get_serial_number();

    // Start command handling thread
    osThreadDef(task_cmd_parse, communication_task, osPriorityNormal, 0, 8000 /* in 32-bit words */); // TODO: fix stack issues
    comm_thread = osThreadCreate(osThread(task_cmd_parse), NULL);

    while (!endpoint_list_valid) {
        osDelay(1);
    }

    start_usb_server();
}

// Thread to handle deffered processing of USB interrupt, and
// read commands out of the UART DMA circular buffer
void communication_task(void * ctx) {
    (void) ctx; // unused parameter


    // TODO: this is supposed to use the move constructor, but currently
    // the compiler uses the copy-constructor instead. Thus the make_obj_tree
    // ends up with a stupid stack size of around 8000 bytes. Fix this.
    auto tree_ptr = new (tree_buffer) tree_type(make_obj_tree());
    fibre_publish(*tree_ptr);

    // Allow main init to continue
    endpoint_list_valid = true;
    
    //start_uart_server();


    /*
    if (board_config.enable_i2c_instead_of_can) {
        start_i2c_server();
    } 
    else {
        // TODO: finish implementing CAN
        // start_can_server(can1_ctx, CAN1, serial_number);
    }
    */

    for (;;) {
        osDelay(1000); // nothing to do
    }
}

extern "C" {
    int _write(int file, const char* data, int len);
}

// @brief This is what printf calls internally
int _write(int file, const char* data, int len) {
#ifdef USB_PROTOCOL_STDOUT
    usb_stream_output_ptr->process_bytes((const uint8_t *)data, len, nullptr);
#endif
#ifdef UART_PROTOCOL_STDOUT
    uart4_stream_output_ptr->process_bytes((const uint8_t *)data, len, nullptr);
#endif
    return len;
}